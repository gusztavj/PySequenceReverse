import * as vscode from 'vscode'
import sanitize = require('sanitize-filename');
import { CallAnalyzer } from './call-analyzer';
import { CodeAnalyzer } from './code-analyzer';

// ################################################################################################################################
/**
 * Represents a participant in a sequence diagram with class and qualified names.
 */
export class Participant {

    /**
     * The namespace in which the class is defined or the name of the module containing the participant.
     */
    public namespace: string = "";

    /**
     * The class to which the method being called or the method initiating the call belongs. If the participant
     * is not a class member, this is the name of the containing module.
     */
    public class: string = "";

    /**
     * The name of the object this participant identifies with.
     */
    public object: string = "";

    /**
     * The ID of the participant for the diagram code
     */
    public id!: string;

    /**
     * The qualified name of the class. The qualified name may not include the fully qualified name, only as many
     * name compartments as many is required to make it unique within the VS Code workspace.
     */
    public qualifiedName(): string {
        return this.namespace.length === 0 ? `${this.class}` : `${this.namespace}/${this.class}`;
    }
    
    /**
     * Generates a unique name by combining the qualified name and alias.     
     * 
     * This method returns a string that combines the qualified name and alias of an object to create a unique identifier,
     * conforming to UML sequence diagram object notation.
     * 
     * @returns A string representing the unique name generated by combining the qualified name and alias.
     */
    public alias(): string {
        return `${this.object}<br>:${this.qualifiedName()}`
    }

    /**
     * Combines the qualified name and alias to generate a unique name.
     * 
     * This method concatenates the qualified name and alias of an object using a colon as a separator to create a unique name.
     * 
     * @returns A string representing the unique name generated by combining the qualified name and alias.
     */
    public uniqueName(): string {
        return `${this.qualifiedName()}:${this.alias()}`;
    }
            
}

/**
 * Represents a collection of participants with unique names and IDs.
 * 
 * This class extends the Map object to store Participant objects with unique names and automatically assigns IDs to them.
 * 
 * @extends Map
 */
export class Participants extends Map<string, Participant> {

    /**
     * Represents a unique identifier for assigning incremental IDs.
     * 
     * This private property holds a number that serves as a unique identifier for assigning incremental IDs within the class.
     * 
     * @type {number}
     */
    private uid: number = 0;

    /**
     * Adds a Participant to the collection, sets it with a unique name, and returns the added Participant.
     * 
     * This method adds a Participant to the collection by setting it with a unique name. If the Participant already exists,
     * it returns the existing Participant; otherwise, it adds the Participant and returns it.
     * 
     * @param participant - The Participant object to add to the collection.
     * @returns The added Participant or the existing one if already present in the collection.
     */
    public add(participant: Participant): Participant {

        this.set(participant.uniqueName(), participant);        
        return this.get(participant.uniqueName()) || participant;
    }

    /**
     * Sets a key-value pair in the Participants collection, assigns an ID to the Participant if it's new, and returns the collection for chaining.
     * 
     * This method sets a key-value pair in the Participants collection. If the Participant with the unique name does not exist in the collection,
     * an ID is assigned to the Participant, and it is added to the collection. The method returns the collection to support method chaining.
     * 
     * @param key - The key to set in the collection.
     * @param value - The Participant object to set in the collection.
     * @returns The Participants collection for chaining purposes.
     */
    public set(key: string, value: Participant): this {
        
        if (!this.has(value.uniqueName())) {
            value.id = `p${++this.uid}`;        
            super.set(value.uniqueName(), value);
        } 
        
        // Return 'this' to maintain chaining compatibility
        return this;
    }

}

// ################################################################################################################################
/**
 * Represents a model for a sequence diagram, including participants and messages.
 */
export class SequenceDiagramModel {

    /**
     * The set of participants contributing to the sequence diagram. One participant is listed only once.
     * Note that a participant is either an object or a module, but it's never a class.
     */
    public participants: Participants = new Participants();

    /**
     * The message exchanges conducted between participants in the order they happen.
     */
    public messages: string[] = [];

    /**
     * Retrieves the CallHierarchyItem representing the analyzed function.
     * 
     * This method returns the CallHierarchyItem that represents the analyzed function within the class.
     * 
     * @returns The CallHierarchyItem representing the analyzed function.
     */
    public functionAnalyzed(): vscode.CallHierarchyItem { return this._functionAnalyzed; }
    protected _functionAnalyzed: vscode.CallHierarchyItem;

    
    /**
     * Retrieves the common root path of the workspace folders.
     * 
     * This method returns the common root path of the workspace folders used in the class.
     * 
     * @returns A string representing the common root path of the workspace folders.
     */
    public workspaceRoot(): string { return this._workspaceRoot; }
    protected _workspaceRoot: string = "";

    /**
     * Retrieves the name of the class to which the function being analyzed in this object belongs.
     * Empty for functions implemented outside classes.
     * 
     * @returns A string representing the name of the class.
     */
    public className(): string { return this._className; }    
    protected _className: string = ""

    /**
     * Retrieves the title of the diagram, calculated from the namespace, the name of the function being analyzed
     * and the name of the container class.
     * 
     * @returns A string representing the title of the object.
     */
    public title(): string { return this._title; }
    protected _title: string = "";

    
    /**
     * Retrieves the Mermaid-speaking contents of the represented sequence diagram.
     * 
     * @returns The sequence diagram in Mermaid language.
     */
    public contents(): string { return this._contents; }
    public _contents: string = "";

    /**
     * Constructs a new instance of the class with the provided root CallHierarchyItem.
     * 
     * This constructor initializes a new instance of the class with the root CallHierarchyItem passed as a parameter.
     * 
     * @param root - The root CallHierarchyItem to be set for the instance.
     */
    constructor(root: vscode.CallHierarchyItem) {
        this._functionAnalyzed = root;
    }

    // ****************************************************************************************************************************
    /**
     * Composes a sequence diagram based on the provided root CallHierarchyItem.
     * 
     * @param {vscode.CallHierarchyItem} root - The root CallHierarchyItem to build the diagram around.
     * @returns {Promise<string>} A Promise that resolves with the composed sequence diagram string.
     */
    public async composeDiagram(): Promise<string> {
        
        this._workspaceRoot = CallAnalyzer.workspaceRoot();
        this._className = await CodeAnalyzer.findClassName(this.functionAnalyzed().uri, this.functionAnalyzed().range.start) || "";
        this._title = 
            `Sequence diagram of ${this.className()}.${this.functionAnalyzed().name}()` +
            ` of ${this.functionAnalyzed().uri.toString().replace(this.workspaceRoot(), "")}`        
                
        const participantsStr = [...this.participants.values()].map(p => `    participant ${p.id} as ${p.alias()}`).join('\n');
        const messagesStr = this.messages.join('\n');

        // The replace at the end is to make sure the lines are not indented in the diagram file as they are below
        const combinedStr = `
            %%{init: {'theme':'forest'}}%%
            sequenceDiagram

                Title ${this.title()}

            ${participantsStr}
            
            ${messagesStr}
        `.replace(/^\s{12,13}/gm, "\n");
        
        this._contents = combinedStr;

        return combinedStr;
    }
}





// ################################################################################################################################
/**
 * Represents information about a call item, including function status, object name, and parameters.
 */
export class CallItemInfo {

    /**
     * Tells if the item being called is a function or not, even if you wonder what the hell it can be if not a function.
     */
    public isFunction: boolean = false;
    
    /**
     * The name of the object on which the call is made. For foo.bar(), it's foo.
     */
    public objectName: string = "";
    
    /**
     * Parameters or arguments passed to the callee.
     */
    public parameters: string = "";

    /**
     * The range specifying the locations where the parameters start and end
     */
    public parametersRange!: vscode.Range;
    
}
